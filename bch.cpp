#include <iostream>
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
using namespace std;
 
 #define			RevBit(data,bit)	(data ^= 1<<(bit))  //纠正错误位

/* run this program using the console pauser or add your own getch, system("pause") or input loop */
unsigned int CheckMatrix[26][2]; 
unsigned long long int Data[256]=
{
{0xFF81ABA7C44F0000 },{0xFF81ABA7C44F0002 },{0xFF81ABA7C44F0010 },{0xFF81ABA7C44F0100 },
{0xFF81ABA7CC6F0000 },{0xFF81ABA7CC6F0002 },{0xFF81ABA7CC6F0010 },{0xFF81ABA7CC6F0100 },
{0xFF81ABA74CEF0000 },{0xFF81ABA74CEF0002 },{0xFF81ABA74CEF0100 },{0xFF81ABA744F60000 },
{0xFF81ABA744F60002 },{0xFF81ABA744F60010 },{0xFF81ABA744F60100 },{0xFF81A3A7C44F0000 },
{0xFF81A3A7C44F0010 },{0xFF81A3A7C44F0100 },{0xFF81A3A7CC6F0000 },{0xFF81A3A7CC6F0002 },
{0xFF81A3A7CC6F0010 },{0xFF81A3A7CC6F0100 },{0xFF81A3A74CEF0000 },{0xFF81A3A74CEF0002 },
{0xFF81A3A74CEF0010 },{0xFF81A3A74CEF0100 },{0xFF81A3A744F60000 },{0xFF81A3A744F60002 },
{0xFF81A3A744F60010 },{0xFF81A3A744F60100 },{0xFF81A894C44F0002 },{0xFF81A894C44F0010 },
{0xFF81A894C44F0100 },{0xFF81A894CC6F0000 },{0xFF81A894CC6F0002 },{0xFF81A894CC6F0100 },
{0xFF81A8944CEF0000 },{0xFF81A8944CEF0002 },{0xFF81A8944CEF0010 },{0xFF81A8944CEF0100 },
{0xFF81A89444F60000 },{0xFF81A89444F60002 },{0xFF81A89444F60100 },{0xFF81BAC0C44F0000 },
{0xFF81BAC0C44F0002 },{0xFF81BAC0C44F0010 },{0xFF81BAC0C44F0100 },{0xFF81BAC0CC6F0000 },
{0xFF81BAC0CC6F0002 },{0xFF81BAC0CC6F0010 },{0xFF81BAC0CC6F0100 },{0xFF81BAC04CEF0000 },
{0xFF81BAC04CEF0002 },{0xFF81BAC04CEF0010 },{0xFF81BAC04CEF0100 },{0xFF81BAC044F60000 },
{0xFF81BAC044F60002 },{0xFF81BAC044F60010 },{0xFF81BAC044F60100 },{0xFF83ABA7C44F0000 },
{0xFF83ABA7C44F0002 },{0xFF83ABA7C44F0010 },{0xFF83ABA7C44F0100 },{0xFF83ABA7CC6F0000 },
{0xFF83ABA7CC6F0002 },{0xFF83ABA7CC6F0010 },{0xFF83ABA7CC6F0100 },{0xFF83ABA74CEF0000 },
{0xFF83ABA74CEF0002 },{0xFF83ABA74CEF0010 },{0xFF83ABA74CEF0100 },{0xFF83ABA744F60000 },
{0xFF83ABA744F60002 },{0xFF83ABA744F60010 },{0xFF83ABA744F60100 },{0xFF83A3A7C44F0000 },
{0xFF83A3A7C44F0002 },{0xFF83A3A7C44F0010 },{0xFF83A3A7C44F0100 },{0xFF83A3A7CC6F0000 },
{0xFF83A3A7CC6F0002 },{0xFF83A3A7CC6F0010 },{0xFF83A3A7CC6F0100 },{0xFF83A3A74CEF0000 },
{0xFF83A3A74CEF0002 },{0xFF83A3A74CEF0010 },{0xFF83A3A74CEF0100 },{0xFF83A3A744F60000 },
{0xFF83A3A744F60002 },{0xFF83A3A744F60010 },{0xFF83A3A744F60100 },{0xFF83A894C44F0000 },
{0xFF83A894C44F0002 },{0xFF83A894C44F0010 },{0xFF83A894C44F0100 },{0xFF83A894CC6F0000 },
{0xFF83A894CC6F0002 },{0xFF83A894CC6F0010 },{0xFF83A894CC6F0100 },{0xFF83A8944CEF0002 },
{0xFF83A8944CEF0010 },{0xFF83A8944CEF0100 },{0xFF83A89444F60000 },{0xFF83A89444F60002 },
{0xFF83A89444F60010 },{0xFF83A89444F60100 },{0xFF83BAC0C44F0000 },{0xFF83BAC0C44F0002 },
{0xFF83BAC0C44F0010 },{0xFF83BAC0C44F0100 },{0xFF83BAC0CC6F0000 },{0xFF83BAC0CC6F0002 },
{0xFF83BAC0CC6F0010 },{0xFF83BAC0CC6F0100 },{0xFF83BAC04CEF0000 },{0xFF83BAC04CEF0002 },
{0xFF83BAC04CEF0010 },{0xFF83BAC04CEF0100 },{0xFF83BAC044F60000 },{0xFF83BAC044F60002 },
{0xFF83BAC044F60010 },{0xFF83BAC044F60100 },{0xFC81ABA7C44F0000 },{0xFC81ABA7C44F0002 },
{0xFC81ABA7C44F0100 },{0xFC81ABA7CC6F0000 },{0xFC81ABA7CC6F0002 },{0xFC81ABA7CC6F0010 },
{0xFC81ABA7CC6F0100 },{0xFC81ABA74CEF0000 },{0xFC81ABA74CEF0010 },{0xFC81ABA74CEF0100 },
{0xFC81ABA744F60000 },{0xFC81ABA744F60002 },{0xFC81ABA744F60010 },{0xFC81ABA744F60100 },
{0xFC81A3A7C44F0000 },{0xFC81A3A7C44F0002 },{0xFC81A3A7C44F0010 },{0xFC81A3A7C44F0100 },
{0xFC81A3A7CC6F0000 },{0xFC81A3A7CC6F0002 },{0xFC81A3A7CC6F0010 },{0xFC81A3A7CC6F0100 },
{0xFC81A3A74CEF0000 },{0xFC81A3A74CEF0002 },{0xFC81A3A74CEF0010 },{0xFC81A3A74CEF0100 },
{0xFC81A3A744F60000 },{0xFC81A3A744F60002 },{0xFC81A3A744F60010 },{0xFC81A3A744F60100 },
{0xFC81A894C44F0000 },{0xFC81A894C44F0002 },{0xFC81A894C44F0010 },{0xFC81A894C44F0100 },
{0xFC81A894CC6F0000 },{0xFC81A894CC6F0002 },{0xFC81A894CC6F0010 },{0xFC81A894CC6F0100 },
{0xFC81A8944CEF0000 },{0xFC81A8944CEF0002 },{0xFC81A8944CEF0010 },{0xFC81A8944CEF0100 },
{0xFC81A89444F60000 },{0xFC81A89444F60002 },{0xFC81A89444F60010 },{0xFC81A89444F60100 },
{0xFC81BAC0C44F0002 },{0xFC81BAC0C44F0010 },{0xFC81BAC0C44F0100 },{0xFC81BAC0CC6F0000 },
{0xFC81BAC0CC6F0002 },{0xFC81BAC0CC6F0010 },{0xFC81BAC04CEF0000 },{0xFC81BAC04CEF0002 }, 
{0xFC81BAC04CEF0010 },{0xFC81BAC04CEF0100 },{0xFC81BAC044F60000 },{0xFC81BAC044F60002 },
{0xFC81BAC044F60010 },{0xFC81BAC044F60100 },{0xFF81ABA7C44F0000 },{0xFF81ABA7C44F0002 },
{0xFF81ABA7C44F0010 },{0xFF81ABA7C44F0100 },{0xFF81ABA7CC6F0002 },{0xFF81ABA74CEF0000 },
{0xFF81ABA74CEF0002 },{0xFF81ABA74CEF0010 },{0xFF81ABA74CEF0100 },{0xFF81ABA744F60000 },
{0xFF81ABA744F60002 },{0xFF81ABA744F60010 },{0xFF81ABA744F60100 },{0xFF81A3A7C44F0000 },
{0xFF81A3A7C44F0002 },{0xFF81A3A7C44F0010 },{0xFF81A3A7C44F0100 },{0xFF81A3A7CC6F0000 },
{0xFF81A3A7CC6F0002 },{0xFF81A3A7CC6F0010 },{0xFF81A3A7CC6F0100 },{0xFF81A3A74CEF0000 },
{0xFF81A3A74CEF0002 },{0xFF81A3A74CEF0010 },{0xFF81A3A74CEF0100 },{0xFF81A3A744F60000 },
{0xFF81A3A744F60002 },{0xFF81A3A744F60010 },{0xFF81A3A744F60100 },{0xFF81A894C44F0000 },
{0xFF81A894C44F0002 },{0xFF81A894C44F0010 },{0xFF81A894C44F0100 },{0xFF81A894CC6F0000 },
{0xFF81A894CC6F0002 },{0xFF81A894CC6F0010 },{0xFF81A894CC6F0100 },{0xFF81A8944CEF0000 },
{0xFF81A8944CEF0002 },{0xFF81A8944CEF0010 },{0xFF81A8944CEF0100 },{0xFF81A89444F60000 },
{0xFF81A89444F60002 },{0xFF81A89444F60010 },{0xFF81A89444F60100 },{0xFF81BAC0C44F0000 },
{0xFF81BAC0C44F0002 },{0xFF81BAC0C44F0010 },{0xFF81BAC0C44F0100 },{0xFF81BAC0CC6F0000 },
{0xFF81BAC0CC6F0002 },{0xFF81BAC0CC6F0010 },{0xFF81BAC0CC6F0100 },{0xFF81BAC04CEF0000 },
{0xFF81BAC04CEF0002 },{0xFF81BAC04CEF0010 },{0xFF81BAC04CEF0100 },{0xFF81BAC044F60000},
{0xFF81BAC044F60010 },{0xFF81BAC044F60100}};
 
#define gx 0x05B9<<(26-11)
//get correct remainder 
unsigned int GetFEC(unsigned int CX){     //cx为传输数据，获得cx校验位rx
	unsigned int RX;//16位的数据位
	unsigned int tmp;
	
	CX = CX<<10;
	tmp = CX;
	for(int i=0;i<16;i++){//迭代循环16次，进行16次除法操作，最后剩下10位的余数
		if((CX&0x2000000)!=0){//对CX的最高位是否为1，如果是1，做减法操作（异或）
			CX ^=gx ;//扩展gx到与CX同样是26位，为了方便除法运算
		}
		CX = CX<<1;
	}
	RX = CX>>16;
	

	return RX;
}
//创建表格，一个ex就代表一个rx，为纠错使用
void CreateCheckMatrix(unsigned int CX){
	unsigned int RX;

	CX = 1<<15;
    
	for(int i=0;i<16;i++){
		if(i<16){
			RX = GetFEC(CX);
			CheckMatrix[i][0] = RX;
			CheckMatrix[i][1] = CX<<10;
		}
		CX = CX>>1;
	}
	CX = 1<<9;
	for(int i=0;i<10;i++){
		CheckMatrix[i+16][0] = CX;
		CheckMatrix[i+16][1] = CX;

		CX = CX>>1;
	}
}
//correct data error
unsigned int CorrectError(unsigned int code,unsigned int *value){   //code是需要纠错的，value是返回值，decode为纠错后值
	unsigned int encode = 0;
	unsigned int decode = 0;
	unsigned int res;
	decode  = code;

	//2.1 calculate remainder
	for(int i=0;i<16;i++){//求余数的算法中，只需要除以最高位的16位，余数一定是10位。
		if((code&0x2000000)!=0){
			code ^=gx;
		}
		code = code <<1;
	}
	res  = code>>(26-10);
	//printf("余数 %2x\n",res);
	if(res == 0){
		*value  = decode;
		return 0;   //不需要纠错
	}
	//2.2 纠正一位错误
	for(int i=0;i<26;i++){
		if(res == CheckMatrix[i][0]){
			decode  = decode^CheckMatrix[i][1];
			*value  = decode;
			return 1;
		}
	}
	//2.3 纠正两位错误
	for(int i=0;i<26;i++){
		for(int j=i+1;j<26;j++){
			if(res == (CheckMatrix[i][0]^CheckMatrix[j][0])){
				decode  = decode^CheckMatrix[i][1]^CheckMatrix[j][1];
				*value  = decode;
				return 2;
			}
		}
	}
	return 3; //3位以上无法纠错
}
 
void Conduct64(unsigned long long int test, long int &a, long int &b)  //将64位分为两个26位
 {
	test=(test>>12)&0xfffffffffffff;
    b = test&0x3FFFFFF;  //低26
    a=test = (test>>26); //高26
 }
//此main函数中没有生成校验位的步骤，可以提前生成并嵌入后续再纠错
int main(int argc, char** argv) {
	printf("余数res为0则不需要纠正，为1则需要纠正一位，为2则需要纠正两位，为3则超出纠正位数\n");
	unsigned int AX = 0xff81;   
	unsigned int BX = 0x9f31;
	CreateCheckMatrix(AX);
	unsigned res1 = 0;
	unsigned res2 = 0;  //判断错了多少位
	unsigned decode1,decode2;  //最终纠错结果
	for(int i=0; i<256; i++){
		long int a,b;
		unsigned long long int test = Data[i];
		Conduct64(test, a, b);
		res1 = CorrectError(a,&decode1);
		res2 = CorrectError(b,&decode2);
		printf("%d.高26位余数为:%2x,低26位余数为:%2x\n", i, res1, res2);
		decode1 = decode1>>10;
		decode2 = decode2>>10;
		printf("传输的数据为:%2x", decode1);
		printf("%2x\n", decode2);
	}
	
	getchar();
	return 0;
}